@page "/question/{SegmentId:int}/{SubcategoryId:int}"
@using Microsoft.AspNetCore.Authorization
@using System.Security.Claims
@using ValhallaVaultCyberAwareness.App.Services
@using ValhallaVaultCyberAwareness.DAL.DbModels
@using ValhallaVaultCyberAwareness.DAL.Repository
@inject IRepository<UserResponseModel> userResponseRepository
@inject IRepository<SegmentModel> segmentRepository
@inject IRepository<SubcategoryModel> subcategoryRepository
@inject IRepository<QuestionModel> questionRepository
@inject IRepository<AnswerModel> answerRepository
@inject ISubcategoryService subcategoryService
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@rendermode InteractiveServer

@attribute [Authorize]

<PageTitle>Quiz - segment.Name</PageTitle>

<div class="container bg-white text-dark rounded shadow-sm p-4 my-4">
    @if (!isLoaded)
    {
        <div class="text-center">
            <p><em>Laddar frågor...</em></p>
        </div>
    }
    else if (!showResults)
    {
        @if (subCategories != null && currentSubCategory != null)
        {
            <h2 class="text-center mb-3">@currentSubCategory.Name</h2>
        }

        @if (currentQuestion != null)
        {
        <h4 class="text-center mb-4">@currentQuestion.Title</h4>
        }

        if (answers != null && currentQuestion != null)
        {
            foreach (var answer in answers)
            {
                <div class="form-check">
                    <input class="form-check-input @active" id="answer-@answer.Id" type="radio" name="answerGroup-@currentQuestion.Id"
                           value="@answer.Id" @onclick="() => SelectAnswer(answer)"/>
                    <label class="form-check-label @active @(isSubmitted ? (answer.IsCorrectAnswer ? "text-success" : "text-danger") : "")" 
                    for="answer-@answer.Id">@answer.Answer</label>
                </div>
            }
        }

        @if(explanation != null)
        {
            <br />
            <h5>Förklaring:</h5>
            <label>@explanation</label>         
        }

        <!-- Button Navigation -->
        <div class="d-flex justify-content-between mt-4">


            @if (!isSubmitted)
            {
                <button class="btn btn-outline-success" @onclick="SubmitAnswer">Skicka in svar</button>
            }
            else if (isSubmitted && currentSubcategoryIndex < subCategories.Count() - 1)
            {
                <button class="btn btn-outline-primary" @onclick="@(async () => await NextQuestion())">Nästa</button>
            }
            else
            {
                <button class="btn btn-outline-primary" @onclick="@(async () => await NextQuestion())">Visa resultat</button>
            }
            <span></span> <!-- Placeholder for alignment -->

        </div>
        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger mt-2" role="alert">
                @errorMessage
            </div>
        }
    }
    else
    {
        @if (showResults && segment != null)
        {
            <div class="container bg-white text-dark rounded shadow-sm p-4 my-4 position-relative">
                <div class="position-absolute top-0 end-0 p-1">
                    @if (isPassed)
                    {
                        <div class="alert alert-success" role="alert">
                            Godkänt - @percentageCorrect% klarat
                        </div>
                    }
                    else
                    {
                        <div class="alert alert-danger" role="alert">
                            Underkänt - @percentageCorrect% klarat
                        </div>
                    }
                </div>

                @foreach (var subcategory in subCategories) // Loopa genom alla subkategorier
                {
                    <h2>@subcategory.Name</h2>

                    foreach (var question in subcategory.Questions) // Loopa genom alla frågor inom subkategorin
                    {
                        <div>
                            <strong>@question.Title</strong>

                            @foreach (var answer in question.Answers) // Visa alla svarsalternativ
                            {
                                <div class="form-check">
                                    @if (IsUserSelectedAnswer(question, answer))
                                    {
                                        
                                            <input type="radio" id="@answer.Id"
                                                   name="@("answerGroup" + question.Id)"
                                                   value="@answer.Id"
                                                   checked
                                                   disabled />
                                            <label class="form-check-label" for="@answer.Id" style="@labelStyle">@answer.Answer</label>
                                    }
                                    else
                                    {
                                            <input type="radio" id="@answer.Id"
                                                   name="@("answerGroup" + question.Id)"
                                                   value="@answer.Id"
                                                   
                                                   disabled />
                                            <label class="form-check-label" for="@answer.Id" style="@labelStyle">@answer.Answer</label>
                                    }
                                </div>
                            }
                        </div>
                    }
                }
                <div class="position-absolute bottom-0 end-0 p-1">
                    <a class="btn btn-primary" href="/segment/@segment.CategoryId/@SegmentId">Tillbaka</a>
                </div>
            </div>
        }
    }
</div>

@code {
    [Parameter]
    public int SegmentId { get; set; }
    [Parameter]
    public int SubcategoryId { get; set; }

    private string active = "";
    private string labelStyle = "";
    private ClaimsPrincipal? user;
    private List<SubcategoryModel>? subCategories;
    private List<QuestionModel>? questions;
    private List<AnswerModel>? answers;
    private Dictionary<int, int> selectedAnswers = new();
    private SegmentModel? segment;
    private SubcategoryModel? currentSubCategory;
    private QuestionModel? currentQuestion;
    private AnswerModel? selectedAnswer;
    private string? explanation;
    private string errorMessage = "";
    private string? userId;
    private int currentSubcategoryIndex = 0;
    private double percentageCorrect;
    private bool showResults = false;
    private bool isSubmitted = false;
    private bool isLoaded = false;
    private bool isPassed;



    /*
    * Logik för restriction för questions sidan
    * Så här ser path:en ut: "/question/{SegmentId:int}/{SubcategoryId:int}"
    *
    * Syfte: Att förhindra åtkomst via URL
    *
    * Varför?:
    * När man ska ta sig in i ett segment så måste man klara av det föregående segmentet med
    * 80% rätt eller mer. Man börjar alltså med Del 1, och när det är avklarat kan man
    * gå vidare till Del 2, osv. Man ska inte kunna börja med Del 2 ifall man inte har gjort klart
    * Del 1. Därför får man inte ta sig in till en fråga som tillhör ett segment man inte har tillgång till
    *
    * Att tänka på:
    * - Det finns kategorier som innehåller segment.
    * - Varje segment innehåller flera subkategorier
    * - varje subkategori innehåller en fråga
    * - Varje fråga innehåller flera svar
    *
    * Logik:
    * 1. Ifall man söker sig till sidan in via URL ska man se över att frågan finns i subkategorin, som finns i segmentet
    * 2. Ifall den inte ens finns i segmentet ska man tas till "/Home"
    *
    * 3. Ifall subkategorin finns i segmentet finns så ska man gå vidare till nästa steg
    *
    * 4. Nu behöver man på något sätt se ifall man har påbörjat det föregående segmentet i kategorin
    *      - IFALL man inte har gjort det, Då ska man tas till "/Home"
    *      - Annars kan man gå vidare till nästa steg
    * 5. Nu behöver man på något sätt se över ifall man har klarat av 80% eller mer av det föregående segmentet.
    * 6. Ifall man inte har klarat 80% av det föregående segmentet så ska man tas till "/Home"
    * 7. Ifall man har klarat 80% av det föregående segmentet så kan man gå vidare till nästa steg
    * 
    * 8. I det här sista steget skickas användaren automatiskt till första frågan av segmentet
    *
     *
     */




    protected override async Task OnInitializedAsync()
    {
        await LoadUser();

        var canAccess = await subcategoryService.IsOpenSubcategory(SegmentId, SubcategoryId, userId);

        if (!canAccess)
        {
            NavigationManager.NavigateTo("/Home");
            return;
        }
        segment = await segmentRepository.GetByIdAsync(SegmentId);

        // Hämta alla subkategorier för det angivna segmentet.
        subCategories = await subcategoryRepository.GetSubcategoriesBySegmentAsync(SegmentId);

        currentSubCategory = subCategories.First(s => s.Id == SubcategoryId);
        currentQuestion = currentSubCategory.Questions[0];

        await LoadAnswersForCurrentQuestion();
        // await LoadUser();
        currentSubcategoryIndex = subCategories.FindIndex(sc => sc.Id == SubcategoryId);
        isLoaded = !isLoaded;

        StateHasChanged();
    }

    private async Task LoadAnswersForCurrentQuestion()
    {
        if (currentQuestion != null)
        {
            answers = await answerRepository.GetAnswersByQuestionIdAsync(currentQuestion.Id);

            StateHasChanged();
        }
    }

    private void SelectAnswer(AnswerModel selectedAnswer)
    {
        this.selectedAnswer = selectedAnswer;
        if (currentQuestion != null)
        {
            selectedAnswers[currentQuestion.Id] = selectedAnswer.Id;
        }
    }

    private async Task LoadUser()
    {

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        user = authState.User;

        if (user.Identity != null)
        {

            if (!user.Identity.IsAuthenticated)
            {
                errorMessage = "Användaren är inte autentiserad.";
                return;
            }

            userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "";
            if (string.IsNullOrEmpty(userId))
            {
                errorMessage = "Kunde inte hitta användarens Id.";
                return;
            }
        }
    }

    private async void SubmitAnswer()
    {

        if (selectedAnswer == null)
        {
            errorMessage = "Vänligen välj ett svar.";
            return;
        }

        active = "disabled";
        isSubmitted = true;
        errorMessage = string.Empty;
        explanation = selectedAnswer.Explanation;

        await LoadUser();

        var existingResponse = await userResponseRepository.FindByUserAndQuestionAsync(userId, currentQuestion.Id);

        if (existingResponse != null)
        {
            existingResponse.IsCorrect = selectedAnswer.IsCorrectAnswer;
            existingResponse.AnswerId = selectedAnswer.Id;
            await userResponseRepository.UpdateAsync(existingResponse);
        }
        else
        {
            var userResponse = new UserResponseModel
                {
                    UserId = userId,
                    QuestionId = currentQuestion.Id,
                    IsCorrect = selectedAnswer.IsCorrectAnswer,
                    AnswerId = selectedAnswer.Id
                };

            await userResponseRepository.CreateAsync(userResponse);
        }

    }

    private async Task NextQuestion()
    {
        // Finns det questions kvar? 

        int questionIndex = currentSubCategory.Questions.IndexOf(currentQuestion);

        if(currentSubCategory.Questions.Count() > questionIndex + 1)
        {
            // Det finns en fråga kvar
            currentQuestion = currentSubCategory.Questions[questionIndex + 1];
            selectedAnswer = null;
            isSubmitted = false;
            explanation = null;
            await LoadAnswersForCurrentQuestion();
        }
        else
        {
            // Kolla så det finns en nästa subkategori!
            if (currentSubcategoryIndex + 1 < subCategories.Count)
            {
                NavigationManager.NavigateTo($"/question/{SegmentId}/{SubcategoryId + 1}");
            }
            else
            {
                ShowResult();
            }
        }
    }

    private async Task ShowResult()
    {
        await CalculateResults();
    }

    private async Task CalculateResults()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "";

        // Se till att vi har en giltig användar-ID.
        if (string.IsNullOrEmpty(userId))
        {
            throw new InvalidOperationException("Kunde inte hitta användarens Id.");
        }

        // Hämta alla användarsvar för nuvarande segment.
        var userResponses = await userResponseRepository.GetByUserIdAndSegmentIdAsync(userId, SegmentId);

        // Räkna det totala antalet frågor och antalet rätta svar.
        int totalQuestions = subCategories.SelectMany(sc => sc.Questions).Count();
        int correctAnswers = userResponses.Count(ur => ur.IsCorrect);

        // Beräkna procentandelen av rätta svar.
        percentageCorrect = (int)(((double)correctAnswers / totalQuestions) * 100);
        isPassed = percentageCorrect >= 80;
        showResults = !showResults;

        // Uppdatera komponenten med nya data.
        StateHasChanged();
    }

    private bool IsUserSelectedAnswer(QuestionModel question, AnswerModel answer)
    {
        if (question == null && userId != null)
        {
            return false;
        }
        else
        {
            var userAnswer = userResponseRepository.GetUserResponse(userId, question.Id, answer.Id);

            if (userAnswer != null)
            {
                labelStyle = answer.IsCorrectAnswer ? "color:green;" : "color:red;";
                return true;
            }
            else
            {
                labelStyle = answer.IsCorrectAnswer ? "color:green;" : "";
                return false;
            }
        }
    }
}
