@page "/question/{SegmentId:int}"
@using ValhallaVaultCyberAwareness.DAL.DbModels
@using ValhallaVaultCyberAwareness.DAL.Repository
@inject IRepository<QuestionModel> questionRepository
@inject IRepository<AnswerModel> answerRepository
@inject IRepository<SubcategoryModel> subcategoryRepository
@inject IRepository<SegmentModel> segmentRepository
@rendermode InteractiveServer

@if (segment != null)
{
    <PageTitle>Quiz - @segment.Name</PageTitle>
}
else
{
    <PageTitle>Quiz</PageTitle>
}

<div class="container bg-white text-dark rounded shadow-sm p-4 my-4">
    @if (!isLoaded)
    {
        <div class="text-center">
            <p><em>Laddar frågor...</em></p>
        </div>
    }
    else if (!showResults)
    {
        @if (subcategories != null && currentSubcategoryIndex < subcategories.Count)
        {
            <h2 class="text-center mb-3">@subcategories[currentSubcategoryIndex].Name</h2>
        }

        @if (questions != null && questions.Any())
        {
            <h4 class="text-center mb-4">@currentQuestion.Title</h4>
        }

        @if (answers != null)
        {

            @foreach (var answer in answers)
            {
                <div class="form-check">
                    <input class="form-check-input" type="radio" name="answerGroup-@currentQuestion.Id"
                           value="@answer.Id"
                           checked="@(selectedAnswers.TryGetValue(currentQuestion.Id, out var selectedAnswerId) && selectedAnswerId == answer.Id)"
                           @onchange="@(() => SelectAnswer(answer))" />
                    <label class="form-check-label">@answer.Answer</label>
                </div>
            }
        }

        <div class="d-flex justify-content-between mt-4">
            @if (currentSubcategoryIndex > 0 || currentIndex > 0)
            {
                <button class="btn btn-outline-secondary" @onclick="@(async () => await PreviousQuestion())">Föregående</button>
            }
            else
            {
                <span></span> <!-- Placeholder for alignment -->
            }

            @if (currentIndex < (questions?.Count - 1) || currentSubcategoryIndex < (subcategories?.Count - 1))
            {
                <button class="btn btn-outline-primary" @onclick="@(async () => await NextQuestion())">Nästa</button>
            }
            else
            {
                <button class="btn btn-outline-success" @onclick="SubmitAnswers">Skicka in svaren</button>
            }
        </div>
    }
    else
    {
        @if (showResults)
        {
            <div style="position: relative;">
                @* <img src="path-to-your-image.png" alt="Test Image" style="width: 100%;"> *@
                <div style="position: absolute; top: 10px; right: 10px; background: white; padding: 5px;">
                    @percentageCorrect% klarat
                </div>
            </div>
            foreach (var subcategory in subcategories) // Loopa genom alla subkategorier
            {
                <h2>@subcategory.Name</h2>
                // Subkategoriens namn som rubrik

                foreach (var question in subcategory.Questions) // Loopa genom alla frågor inom subkategorin
                {
                    <div>
                        <strong>@question.Title</strong>

                        @foreach (var answer in question.Answers) // Visa alla svarsalternativ
                        {
                            bool tryGetValueResult = selectedAnswers.TryGetValue(question.Id, out var userSelectedAnswerId);
                            bool isAnswerIdMatching = answer.Id == userSelectedAnswerId;
                            bool isUserSelectedAnswer = tryGetValueResult && isAnswerIdMatching;

                            string labelStyle = isUserSelectedAnswer ?
                                (answer.IsCorrectAnswer ? "color: green;" : "color: red;") :
                                (answer.IsCorrectAnswer ? "color: green;" : "");

                            <div>
                                @if (isUserSelectedAnswer)
                                {
                                    <input type="radio" id="@answer.Id"
                                           name="@("answerGroup" + question.Id)"
                                           value="@answer.Id"
                                           checked="checked"
                                           disabled />
                                }
                                else
                                {
                                    <input type="radio" id="@answer.Id"
                                           name="@("answerGroup" + question.Id)"
                                           value="@answer.Id"
                                           disabled />
                                }

                                <label for="@answer.Id" style="@labelStyle">@answer.Answer</label>
                            </div>
                        }
                    </div>
                }
            }
        }
    }
    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-2" role="alert">
            @errorMessage
        </div>
    }
</div>

@code {
    [Parameter]
    public int SegmentId { get; set; }
    private int? selectedAnswerId { get; set; }

    private int percentageCorrect;

    private SegmentModel? segment;
    private string? category;
    private List<SubcategoryModel>? subcategories;
    private List<QuestionModel>? questions;
    private List<AnswerModel>? answers;
    private List<UserResponseModel> userResponses = new();
    private Dictionary<int, int> selectedAnswers = new Dictionary<int, int>();
    private QuestionModel? currentQuestion;
    private AnswerModel? selectedAnswer;
    private int currentSubcategoryIndex = 0;
    private int currentIndex = 0;
    private bool isLoaded = false;
    private bool showResults = false;
    private string errorMessage = "";

    protected override async Task OnInitializedAsync()
    {
        // Hämta alla subkategorier för det angivna segmentet.
        subcategories = await subcategoryRepository.GetSubcategoriesBySegmentAsync(SegmentId);
        segment = await segmentRepository.GetByIdAsync(SegmentId);

        // Kontrollera om det finns några subkategorier. Om det finns, ladda frågorna för den första subkategorin.
        if (subcategories.Any())
        {
            currentSubcategoryIndex = 0; // Starta med den första subkategorin
            await LoadQuestionsForSubcategory(subcategories[currentSubcategoryIndex].Id);
            isLoaded = true; // Indikera att sidan har laddats och är redo att visas
        }
        else
        {
            isLoaded = true;
        }
    }

    private async Task NextQuestion()
    {
        if (currentIndex < questions.Count - 1)
        {
            currentIndex++;
            currentQuestion = questions[currentIndex];
            selectedAnswerId = null; // Nollställ det valda svaret
            LoadAnswersForCurrentQuestion();
        }
        else if (currentSubcategoryIndex < subcategories.Count - 1)
        {
            currentSubcategoryIndex++;
            await LoadQuestionsForSubcategory(subcategories[currentSubcategoryIndex].Id); // Och här
        }
        else
        {
            showResults = true;
        }
    }

    private async Task PreviousQuestion()
    {
        if (currentIndex > 0)
        {
            currentIndex--;
            currentQuestion = questions[currentIndex];
            selectedAnswerId = null; // Nollställ det valda svaret
            LoadAnswersForCurrentQuestion();
        }
        else if (currentSubcategoryIndex > 0)
        {
            currentSubcategoryIndex--;
            await LoadQuestionsForSubcategory(subcategories[currentSubcategoryIndex].Id, loadLastQuestion: true); // Och här
        }
    }

    private async Task LoadQuestionsForSubcategory(int subcategoryId, bool loadLastQuestion = false)
    {
        try
        {
            questions = await questionRepository.GetQuestionsBySubcategoryAsync(subcategoryId);
            if (questions.Any())
            {
                currentIndex = loadLastQuestion ? questions.Count - 1 : 0;
                currentQuestion = questions[currentIndex];
                await LoadAnswersForCurrentQuestion();
            }
            else
            {
                // Hantera när inga frågor finns
            }
        }
        catch (Exception ex)
        {
        }
    }

    private async Task LoadAnswersForCurrentQuestion()
    {
        if (currentQuestion != null)
        {
            answers = await answerRepository.GetByQuestionIdAsync(currentQuestion.Id);
            StateHasChanged(); // Dettauppdaterar UI med de nya svaren
        }
    }

    private void SelectAnswer(AnswerModel answer)
    {
        if (selectedAnswers.ContainsKey(currentQuestion.Id))
        {
            // Användaren har redan valt ett svar för den här frågan, uppdatera det befintliga svaret
            selectedAnswers[currentQuestion.Id] = answer.Id;
        }
        else
        {
            // Det är första gången användaren väljer ett svar för den här frågan, lägg till det nya svaret
            selectedAnswers.Add(currentQuestion.Id, answer.Id);
        }

        // Uppdatera även UserResponseModel om det behövs
        var existingResponse = userResponses.FirstOrDefault(r => r.QuestionId == currentQuestion.Id);
        if (existingResponse != null)
        {
            existingResponse.IsCorrect = answer.IsCorrectAnswer;
        }
        else
        {
            userResponses.Add(new UserResponseModel
                {
                    QuestionId = currentQuestion.Id,
                    IsCorrect = answer.IsCorrectAnswer
                });
        }
    }

    private void SubmitAnswers()
    {
        bool allQuestionsAnswered = questions.All(q => selectedAnswers.ContainsKey(q.Id));

        if (allQuestionsAnswered)
        {
            // Räkna antalet korrekta svar.
            int correctAnswersCount = questions.Count(q =>
                selectedAnswers.TryGetValue(q.Id, out var selected) &&
                q.Answers.Any(a => a.IsCorrectAnswer && a.Id == selected));

            // Beräkna procentandelen av korrekta svar.
            percentageCorrect = (int)(((double)correctAnswersCount / questions.Count) * 100);

            // Alla frågor har besvarats
            errorMessage = string.Empty;
            showResults = true;
        }
        else
        {
            // Inte alla frågor har besvarats
            errorMessage = "Vänligen svara på alla frågor innan du skickar in dina svar.";
        }

        StateHasChanged(); // Se till att komponenten uppdateras med det nya tillståndet.
    }
}
